---
layout: post
title: AOP with PostSharp
date: '2012-09-07T16:38:00.001+01:00'
author: Sérgio Agostinho
tags:
- Dependency Injection
- PostSharp
- Visual Studio
- ASP.NET
- AOP
- logging
- log4net
- Best Practices
modified_time: '2012-09-07T16:38:45.677+01:00'
thumbnail: http://3.bp.blogspot.com/-sBtjS7bxh5U/UEoUGHLu-NI/AAAAAAAAC7c/l4YlvjWswx8/s72-c/2804.PostSharp.png
blogger_id: tag:blogger.com,1999:blog-6105644668642718046.post-7784211813332701321
blogger_orig_url: http://sergioagostinho-dev.blogspot.com/2012/09/aop-with-postsharp.html
---

<br />No seguimento da apresentação do Vítor Paulino no último encontro do NetPonto decidi voltar ao AOP, e estive a fazer umas experiências com a framework PostSharp em .NET.<br /><br />PostSharp vs AspectJ<br /><br />Ora bem, antes de mais, há que perceber que o PostSharp tem uma visão diferente do AspectJ. Nomeadamente o AspectJ é uma extensão à linguagem Java (que introduz o artefacto aspect), enquanto que o PostSharp é uma framework para .NET. Isto significa que a curva de aprendizagem é mais baixa, porque não há nada de novo para o developer .NET, essencialmente um aspecto é um classe que estende uma classe especifica (nos casos mais simples) ou implementa um interface em particular (quando queremos usar funcionalidades mais avançadas). Algo que torna a curva de aprendizagem do PostSharp mais leve é o facto de nos aspectos mais simples não haver inversion of control, isto é, são as próprias classes que dizem declarativamente (através de atributos) que aspectos se lhe aplicam. (Também é possível fazer ao contrário, para componentes legacy ou quando não temos a source.)<br /><br />Experiências<br /><br />O PostSharp é pago, mas as experiências que andei a fazer foram com a versão Starter (registada com licença gratuita e utilizável em projectos sem ter de pagar licença). Corre em .NET 4.0, mesmo em Client Profile. O código é auto-explicatório, mas a ideia foi fazer alguns aspectos simples reutilizáveis. Pode ser interessante ter uma biblioteca de aspectos.<br /><br />Baseei-me nos posts do blog e samples, fazendo alterações onde me pareceu interessante.<br /><br /><table cellpadding="0" cellspacing="0" class="tr-caption-container" style="float: left; margin-right: 1em; text-align: left;"><tbody><tr><td style="text-align: center;"><a href="http://3.bp.blogspot.com/-sBtjS7bxh5U/UEoUGHLu-NI/AAAAAAAAC7c/l4YlvjWswx8/s1600/2804.PostSharp.png" imageanchor="1" style="clear: left; margin-bottom: 1em; margin-left: auto; margin-right: auto;"><img border="0" height="400" src="http://3.bp.blogspot.com/-sBtjS7bxh5U/UEoUGHLu-NI/AAAAAAAAC7c/l4YlvjWswx8/s400/2804.PostSharp.png" width="388" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Solution class diagram</td></tr></tbody></table><br /><br />NoNullArguments<br /><br />Foi o primeiro que me lembrei. Se são adeptos de programação defensiva ou é prática da empresa, e validam se todos os parâmetros dos métodos/construtores são null, este é um "no-brainer".<br /><br />Antes:<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; public MyBusinessLogic(IDataContext dataContext, ISettings settings)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (dataContext == null)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new ArgumentException("dataContext");<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (settings == null)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new ArgumentException("settings");<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DataContext = dataContext;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Settings = settings;<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />Depois:<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; [NoNullArguments]<br />&nbsp; &nbsp; &nbsp; &nbsp; public MyBusinessLogic(IDataContext dataContext, ISettings settings)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DataContext = dataContext;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Settings = settings;<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br /><br /><br />AspectProfiler / ConsoleProfiler<br /><br />É um dos exemplos do site. Não gostei do original estar coupled ao Trace (e eu gostaria de usar o log4net ;)) e portanto tornei-o uma classe abstracta que obriga a implementar um método Debug() concreto. É um padrão que uso nos restantes aspectos. Não é uma solução perfeita, porque ao aplicarmos um aspecto concreto ficamos coupled a essa implementação e perdemos a vantagem de separar o aspecto (profiling) da implementação de como o profile vai ser registado. A solução é ideal será usar uma classe concreta onde com um membro de tipo interface com a implementação do Debug(), que seria definida por dependency injection. No entanto, por motivos de simplificação (:)), optei por esta implementação. O objectivo é mostrar as potencialidades do AOP, o IoC é outra guerra,,, (e confesso: não tenho experiência suficiente em nenhum IoC container)<br /><br />Exemplo:<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; [ConsoleProfiler] &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; public MyBusinessLogic(IDataContext dataContext, ISettings settings)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DataContext = dataContext;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Settings = settings;<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />Este aspecto (tal como os subsequentes) pode ser aplicado a nível do método, a nível da classe (e portanto aplica-se a todos os métodos), ou mesmo a nível da Assembly (aí aplicando-se a todos métodos de todas as classes). Neste último caso, pode ser colocado no AssemblyInfo.cs:<br /><br />[assembly: ConsoleProfiler(AttributeExclude = true, AttributePriority = 0, AttributeTargetMemberAttributes = MulticastAttributes.CompilerGenerated)]<br /><br /><br />AbstractCache / MemoryCache<br /><br />É outro clássico, adaptado de exemplos do site. Neste caso deleguei o método Get() e Set() de cache na classe concreta, e defini um GenerateKey() que pode ser redefinido nas classes concretas. Como proof-of-concept, implementei um cache simples in-memory, mas thread-safe (via ConcurrentDictionary).<br /><br />Heis um exemplo, em conjunto com profiling:<br /><br />&nbsp; &nbsp; public class DataContext : IDataContext<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; #region IDataContext Members<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; [MemoryCache]<br />&nbsp; &nbsp; &nbsp; &nbsp; [ConsoleProfiler]<br />&nbsp; &nbsp; &nbsp; &nbsp; public Customer GetCustomer(int id)<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Thread.Sleep(1000);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return new Customer() {Name = "John Doe"};<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; #endregion<br />&nbsp; &nbsp; }<br /><br />(...)<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;var context = new DataContext();<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (int i = 0; i &lt; 10; i++)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context.GetCustomer(616);<br /><br /><br /><br />Como bónus aproveitei a dica do site e meti um regra a nível de compile-time para impedir que se marquem métodos com tipos de retorno "não cacháveis", por exemplo: Stream, IEnumerable, IQueryable. Isto é muito interessante, pois aplica-se a sub-tipos destes tipos (no passado já tive problemas ao tentar "cachar" MemoryStreams na cache ASP.NET). Caso o código esteja marcado, o Visual Studio não compila o projecto. Heis um exemplo:<br /><br />&nbsp; &nbsp; public class MyBusinessLogic : IMyBusinessLogic<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; [MemoryCache]<br />&nbsp; &nbsp; &nbsp; &nbsp; public MemoryStream MyStream { get; set; }<br />&nbsp; &nbsp; }<br />Note-se que por omissão o número da linha onde o erro ocorre não é mostrado no Visual Studio. Para isso acontecer é preciso alterar a configuração.<br /><br />AbstractIoCResolution / MyIoCResolution<br /><br />Não é o meu exemplo preferido, mas mostra como é possível injectar dependências em propriedades, de forma lazy. Por alguma razão que não aprofundei, parece não funcionar a nível da interface.<br /><br />&nbsp; &nbsp; public class MyBusinessLogic : IMyBusinessLogic<br />&nbsp; &nbsp; {<br />...<br />&nbsp; &nbsp; &nbsp; &nbsp; #region IMyBusinessLogic Members<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; public IDataContext DataContext { get; set; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; [MyIoCResolution]<br />&nbsp; &nbsp; &nbsp; &nbsp; public ISettings Settings { get; set; }<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; #endregion<br />&nbsp; &nbsp; }<br />Conclusão<br /><br />Embora não seja pau para toda a obra, em aplicações com uma base de código grande o PostSharp pode ter algumas utilizações pontuais onde remove código boilerplate sem grandes mudanças de paradigma. Se se lembrarem de outros exemplos interessantes, partilhem :)<br /><br />You can find the <a href="https://www.dropbox.com/home/Public?select=Sandbox.PostSharp.zip" target="_blank">source code here</a>.<br /><br /><i>Note: this is basically a <a href="http://pontonetpt.org/blogs/labs2/archive/2012/06/06/aop-com-postsharp.aspx" target="_blank">repost from my previous blog</a>.</i>