---
layout: post
title: 'An automated testing strategy for multi-component systems - Part 1: Unit Tests'
date: '2015-06-26T20:55:00.000+01:00'
author: Sérgio Agostinho
tags:
- Java
- ".Net"
- TDD
- microservices
- Unit Testing
modified_time: '2015-06-26T20:55:12.604+01:00'
thumbnail: http://4.bp.blogspot.com/-oVBDy3sJ8lY/VY2jo6ngcpI/AAAAAAAAJ5w/oSpvUFE_HG0/s72-c/overview.png
blogger_id: tag:blogger.com,1999:blog-6105644668642718046.post-1629195345641467565
blogger_orig_url: http://sergioagostinho-dev.blogspot.com/2015/06/an-automated-testing-strategy-for-multi.html
---

<div style="text-align: justify;"><i>In this series of posts, I describe an approach my team is using for automated testing of multi-component systems. In the first post, I describe our approach for Unit Testing.</i></div><div style="text-align: justify;"><br /></div><h2>Context</h2><div style="text-align: justify;">I've started working in a new team last March, and we have defining an automated testing strategy that fits our team. Currently, we are developing a set of back-end "small", independently deployable services with specific responsibilities, something which is now currently called a&nbsp;<a href="http://martinfowler.com/articles/microservices.html">microservices architecture</a>. Some of these services are "front-facing", in the sense that they serve front-end client applications, while others serve back-end services; in any case, both of these interactions occur with applications that are developed by other teams. Most of the components we develop are implemented in the Java stack for Linux, while the remaining are implemented in .NET stack for Windows.<br /><br /></div><h2>Overview</h2>Since most of team started the project at the same time, and none of us were particular experienced in the technological stack, we did a lot of experimenting. It quickly became apparent that we needed at least three levels of automated tests. After a lot of discussion, we came up with the following:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-oVBDy3sJ8lY/VY2jo6ngcpI/AAAAAAAAJ5w/oSpvUFE_HG0/s1600/overview.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="186" src="http://4.bp.blogspot.com/-oVBDy3sJ8lY/VY2jo6ngcpI/AAAAAAAAJ5w/oSpvUFE_HG0/s640/overview.png" width="640" /></a></div><br /><br /><div style="text-align: justify;">Interestingly, after our definition, we stumbled upon Thoughtworks' presentation "<a href="http://martinfowler.com/articles/microservice-testing/" target="_blank">Testing Strategies in a&nbsp;Microservice Architecture</a>", which sharing some similarities with our approach (which is a good thing :)). Their approach is more complex than ours, perhaps due to nature of the systems they develop. Naming aside, I think our approach is a sub-set of theirs.</div><div style="text-align: justify;"><br /></div><h2 style="text-align: justify;">Unit Testing</h2><div><br /></div><h3>Definition</h3><div><br />Unit Tests are the most know type of automated testing. And yet, I think most of the times they are incorrectly done. So what is a Unit Test? There are several definitions. I like <a href="http://blog.ploeh.dk/2015/05/07/functional-design-is-intrinsically-testable/" target="_blank">Mark Seemann's</a>:&nbsp;</div><blockquote class="tr_bq">"<i>A unit test is an automated test that tests a unit in isolation from its dependencies.</i>"</blockquote>Still, as he points out, this isn't a very precise definition. Well, for most people that develop in object-oriented programming languages, and in my experience, the System Under Test (SUT) is a single class method.<br /><br /><h3>What should we test?</h3><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Based on our experience, <a href="http://martinfowler.com/bliki/TestCoverage.html" target="_blank">Code Coverage</a> is not a quality metric, and so we are not aiming for test coverage. That means that we are <i>not </i>testing all code, purposely. Furthermore, we are not doing Test Driven Development (I do think we <i>should</i>, but that is a discussion for another day). Our rule is that we should test <i>at least</i> "domain" classes, and "infrastructure" classes when possible.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Regarding visibility, we only test <b>public</b> methods and constructors. It's not consensual in the team on whether we should test public constructors. I think we should test them if they have logic in them. Preconditions assertions (sometimes called "Guard clauses" in the .NET world) are a grey area.</div><div style="text-align: justify;">(...)</div><div style="text-align: justify;"><br /></div><h3 style="text-align: justify;">What don't we need to test?</h3><div style="text-align: justify;"><br /></div><div style="text-align: justify;">...</div><div style="text-align: justify;"><br /></div><h3 style="text-align: justify;">Stack</h3><div style="text-align: justify;"><br /></div><div style="text-align: justify;">...</div><div style="text-align: justify;"><br /></div><h3 style="text-align: justify;">Project Structure</h3><div style="text-align: justify;">...</div><div style="text-align: justify;"><br /></div><h3 style="text-align: justify;">Test case naming</h3><div style="text-align: justify;">...</div><br /><i>Thanks to <a href="http://build-failed.blogspot.com/" target="_blank">Pedro Sousa</a>, João Acabado, Hugo Silvério, Bruno Oliveira, and João Belo, as this a product of our discussions.</i>