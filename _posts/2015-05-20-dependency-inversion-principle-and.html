---
layout: post
title: Checked exceptions in Java
date: '2015-05-20T23:39:00.001+01:00'
author: SÃ©rgio Agostinho
tags:
- Java
- C#
- SOLID
- Unit Testing
modified_time: '2015-05-20T23:43:21.850+01:00'
thumbnail: http://3.bp.blogspot.com/-WOclcb9onhI/VV0L23zI_WI/AAAAAAAAJ1o/Pv6W9u1wmaU/s72-c/diagram-3464475650202648769.png
blogger_id: tag:blogger.com,1999:blog-6105644668642718046.post-511152416881542890
blogger_orig_url: http://sergioagostinho-dev.blogspot.com/2015/05/dependency-inversion-principle-and.html
---

<i>In this post I describe some issues I had with checked exceptions in Java, and my current approach to handle them.</i><br /><br /><div style="text-align: justify;">When I developed in Java non-professionally some years ago, I found the checked exception mechanism interesting. The possibility to add to a method's contract the exceptions it throws, and therefore enforce that they are handled at compile seemed a good idea. (<a href="http://sergioagostinho-dev.blogspot.pt/2007/06/c-first-look.html" target="_blank">I actually missed them when I first started developing in C#</a>). Now that I a more experienced developer and that I try to apply the SOLID principles, I'm not so sure.</div><br /><h3>Dependency Inversion Principle</h3><div><br /></div><span style="text-align: justify;">When you are applying the </span><a href="http://en.wikipedia.org/wiki/Dependency_inversion_principle" style="text-align: justify;" target="_blank">Dependency Inversion Principle</a><span style="text-align: justify;">, classes depend on interfaces, not the actual implementations. Let's say you have a </span><span style="font-family: Courier New, Courier, monospace; text-align: justify;">Serializer</span><span style="text-align: justify;"> interface with a</span><span style="font-family: inherit; text-align: justify;"> single</span><span style="font-family: Courier New, Courier, monospace; text-align: justify;"> serialize()</span><span style="text-align: justify;"> method and </span><span style="font-family: Courier New, Courier, monospace; text-align: justify;">SerializerImpl&nbsp;</span><span style="text-align: justify;">class. So if </span><span style="font-family: Courier New, Courier, monospace; text-align: justify;">SerializerImpl</span><span style="text-align: justify;"> has a </span><span style="font-family: Courier New, Courier, monospace; text-align: justify;">serialize()</span><span style="text-align: justify;"> implementation which throws an exception, then </span><span style="font-family: Courier New, Courier, monospace; text-align: justify;">Serializer</span><span style="text-align: justify;"> must also declare it throws that exception on </span><span style="font-family: Courier New, Courier, monospace; text-align: justify;">serialize()</span><span style="text-align: justify;">. It seems to me a bit awkward that the interface must know which exceptions the actual implementation throws, but that doesn't seem to break any SOLID principle too much, so I can live with that.</span><br /><br /><div style="text-align: justify;">What happens when you need to have must implementations of that class? Let's say you need to implement an XML, a JSON and a Protobuff serializer. Each <span style="font-family: Courier New, Courier, monospace;">serialize()</span> implementation will probably need to declare the exceptions it throws. For simplicity sake, let's say&nbsp;<span style="font-family: Courier New, Courier, monospace;">XmlSerializer</span> throws <span style="font-family: Courier New, Courier, monospace;">XmlException</span>, <span style="font-family: Courier New, Courier, monospace;">JsonSerializer</span> throws <span style="font-family: Courier New, Courier, monospace;">JsonException</span>, and <span style="font-family: Courier New, Courier, monospace;">ProtobuffException</span><span style="font-family: inherit;">&nbsp;(in reality, depending on the framework you use in each of the implementations that may need to throw more than on).</span> But then, the <span style="font-family: Courier New, Courier, monospace;">Serializer </span>interface must also declare it throws the exceptions each implementation throws, which mean that each implementation must know all the exceptions the other implementations throw. That means that all the <span style="font-family: Courier New, Courier, monospace;">Serializer</span> implementation are coupled with each other, and the interface is coupled with each one of the implementations. This definitely doesn't seem right!</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">So, my approach was to introduce a new exception: <span style="font-family: Courier New, Courier, monospace;">SerializerException</span><span style="font-family: inherit;"> and change the </span><span style="font-family: Courier New, Courier, monospace;">serialize()</span><span style="font-family: inherit;"> method to throw only this exception.&nbsp;</span>The purpose of this exception is to wrap the actual exceptions thrown by the frameworks used for each of the serialization methods. It adds the extra work of having to define a new exception, but it decouples the Serializer from all the implementations, and decouples each implementation from all the others.</div><div style="text-align: justify;"><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-WOclcb9onhI/VV0L23zI_WI/AAAAAAAAJ1o/Pv6W9u1wmaU/s1600/diagram-3464475650202648769.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="222" src="http://3.bp.blogspot.com/-WOclcb9onhI/VV0L23zI_WI/AAAAAAAAJ1o/Pv6W9u1wmaU/s640/diagram-3464475650202648769.png" width="640" /></a></div><div style="text-align: justify;"><br /></div><h3 style="text-align: justify;">Checked or unchecked?</h3><div><br /></div><div style="text-align: justify;">While this approach seems good, it's only elegant for simple applications, that is, if your application entry point invokes the <span style="font-family: Courier New, Courier, monospace;">Serializer</span>. If you have a non-trivial application with a more complex dependency tree, and you just want to handle exceptions at the high-level, then it becomes cumbersome. Let's say you entry point class invokes a method <span style="font-family: Courier New, Courier, monospace;">foobar()</span> in class <span style="font-family: Courier New, Courier, monospace;">Foobar</span>, which invokes a method <span style="font-family: Courier New, Courier, monospace;">foo()</span> in class <span style="font-family: Courier New, Courier, monospace;">Foo</span>, which then invokes a method bar() in class Bar, which finally invokes serialize(). All these methods: <span style="font-family: Courier New, Courier, monospace;">foo()</span>, <span style="font-family: Courier New, Courier, monospace;">bar()</span> and <span style="font-family: Courier New, Courier, monospace;">foobar()</span> must declare that they throw <span style="font-family: Courier New, Courier, monospace;">SerializerException</span>, regardless of their responsibility. Also, if you have unit tests for these classes, then each test method must also declare it throws <span style="font-family: Courier New, Courier, monospace;">SerializerException</span>.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">My approach was to make <span style="font-family: Courier New, Courier, monospace;">SerializerException</span> extend <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/RuntimeException.html" target="_blank">RuntimeException</a> instead of the (checked) <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Exception.html" target="_blank">Exception</a>. This means that the <span style="font-family: Courier New, Courier, monospace;">Serializer</span> interface (and any implementation) no longer need to declare it throws any exception, so the code becomes much simpler. However, I did document that the method throws the exception using the <span style="font-family: Courier New, Courier, monospace;">@throws</span> javadoc comment. (This is pretty much the approach used in C#).</div><div style="text-align: justify;"><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-rSnrnC2MKRw/VV0MYs-p33I/AAAAAAAAJ1w/rT2akAQPDE0/s1600/diagram-6053943533270054517.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="222" src="http://4.bp.blogspot.com/-rSnrnC2MKRw/VV0MYs-p33I/AAAAAAAAJ1w/rT2akAQPDE0/s640/diagram-6053943533270054517.png" width="640" /></a></div><div style="text-align: justify;"><br /></div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">As a I did this, I did do some research. Oracle's documentation on the matter (<a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/runtime.html" target="_blank">Unchecked exceptions - the controversy</a>) didn't convince me, and lot of people&nbsp;<a href="https://ourcraft.wordpress.com/2009/01/15/checked-exceptions-good-or-bad/" target="_blank">shared my opinion</a>, but none of them was quite an authority. Then I found Bruce Eckel's book "<a href="http://www.amazon.co.uk/Thinking-Java-Bruce-Eckel/dp/0131872486" target="_blank">Thinking in Java</a>" (4th edition). Namely in Chapter 9, section "Perspectives", page 347, he has a <a href="https://books.google.co.uk/books?id=Ql6QgWf6i7cC&amp;pg=PA414&amp;dq=martin+fowler+java+checked+exceptions&amp;hl=en&amp;sa=X&amp;ei=xwddVajCG8vd7QaNtYOIDQ&amp;ved=0CCEQ6AEwAA#v=onepage&amp;q=martin%20fowler%20java%20checked%20exceptions&amp;f=false" target="_blank">similar opinion to mine</a>&nbsp;(and so does Martin Fowler).</div><div style="text-align: justify;"><br /></div><h3 style="text-align: justify;">Conclusion</h3><div><br /></div><div style="text-align: justify;">In my opinion, avoid checked exceptions in Java unless you are doing a trivial application. If you need to work with checked exceptions, wrap them in your own unchecked exception. The extra work needed outweighs the clarity and decoupling you obtain in your code base. Nevertheless, documenting these exceptions in javadocs and properly (unit) testing your code is also necessary,</div><br /><br /><br /><br /><br /><br />